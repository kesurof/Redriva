#!/usr/bin/env python3
"""
Redriva - Synchroniseur Real-Debrid
====================================
Outil de synchronisation Python pour archiver vos torrents Real-Debrid 
dans une base de donn√©es SQLite locale.

Maintenu via Claude/Copilot - Architecture monolithique organis√©e

TABLE DES MATI√àRES:
==================
1. IMPORTS ET CONFIGURATION          (lignes 1-80)
2. UTILITAIRES ET HELPERS           (lignes 81-150)  
3. BASE DE DONN√âES                  (lignes 151-220)
4. API REAL-DEBRID                  (lignes 221-400)
5. SYNCHRONISATION                  (lignes 401-700)
6. STATISTIQUES ET ANALYTICS        (lignes 701-850)
7. DIAGNOSTIC ET MAINTENANCE        (lignes 851-950)
8. INTERFACE UTILISATEUR (MENU)     (lignes 951-1100)
9. POINT D'ENTR√âE PRINCIPAL         (lignes 1100+)

Fonctionnalit√©s principales:
- üîÑ Synchronisation intelligente avec modes optimis√©s
- üìä Statistiques compl√®tes et analytics avanc√©es  
- üîç Diagnostic automatique des erreurs
- üéÆ Menu interactif convivial
- ‚ö° Performance optimis√©e avec contr√¥le dynamique
"""

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                         SECTION 1: IMPORTS ET CONFIGURATION                ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

import os
import sys
import argparse
import asyncio
import aiohttp
import sqlite3
import time
import signal
import logging
import json
from pathlib import Path

def load_env_file():
    """
    Charge les variables d'environnement depuis le fichier .env
    
    Permet une configuration flexible sans modifier le code.
    Variables support√©es: RD_TOKEN, RD_MAX_CONCURRENT, RD_BATCH_SIZE, etc.
    """
    env_file = Path(__file__).parent.parent / '.env'
    if env_file.exists():
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    # Ne pas √©craser les variables d√©j√† d√©finies
                    if key.strip() not in os.environ:
                        os.environ[key.strip()] = value.strip()

# Chargement des variables d'environnement depuis .env
load_env_file()

# Configuration du logging avec format enrichi
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

# Gestion de l'interruption propre (CTRL+C)
stop_requested = False
def handle_sigint(signum, frame):
    """Gestionnaire d'interruption propre pour √©viter la corruption de donn√©es"""
    global stop_requested
    logging.warning("Interruption clavier re√ßue (CTRL+C), arr√™t propre...")
    stop_requested = True

signal.signal(signal.SIGINT, handle_sigint)

# Configuration via variables d'environnement avec valeurs par d√©faut optimis√©es
RD_API_URL = "https://api.real-debrid.com/rest/1.0/torrents"
DB_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '../data/redriva.db'))
MAX_CONCURRENT = int(os.getenv('RD_MAX_CONCURRENT', '50'))    # Requ√™tes simultan√©es
BATCH_SIZE = int(os.getenv('RD_BATCH_SIZE', '250'))          # Taille des batches
QUOTA_WAIT_TIME = int(os.getenv('RD_QUOTA_WAIT', '60'))      # Attente quota global (sec)
TORRENT_QUOTA_WAIT = int(os.getenv('RD_TORRENT_WAIT', '10')) # Attente quota torrent (sec)

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                         SECTION 2: UTILITAIRES ET HELPERS                 ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def format_size(bytes_size):
    """
    Convertit les bytes en format lisible (KB, MB, GB, TB)
    
    Args:
        bytes_size (int): Taille en bytes
        
    Returns:
        str: Taille format√©e avec unit√© appropri√©e
        
    Example:
        >>> format_size(1536000000)
        '1.4 GB'
    """
    if bytes_size is None:
        return "N/A"
    
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_size < 1024.0:
            return f"{bytes_size:.1f} {unit}"
        bytes_size /= 1024.0
    return f"{bytes_size:.1f} PB"

def get_status_emoji(status):
    """
    Retourne un emoji repr√©sentatif selon le statut du torrent
    
    Args:
        status (str): Statut du torrent
        
    Returns:
        str: Emoji correspondant au statut
    """
    status_emojis = {
        'downloaded': '‚úÖ',      # T√©l√©chargement termin√©
        'downloading': '‚¨áÔ∏è',     # En cours de t√©l√©chargement
        'waiting': '‚è≥',         # En attente
        'queued': 'üîÑ',          # En file d'attente
        'error': '‚ùå',           # Erreur
        'magnet_error': 'üß≤‚ùå',   # Erreur magnet
        'magnet_conversion': 'üß≤', # Conversion magnet
        'virus': 'ü¶†',           # Virus d√©tect√©
        'dead': 'üíÄ',            # Torrent mort
        'uploading': '‚¨ÜÔ∏è',       # Upload en cours
        'compressing': 'üóúÔ∏è'      # Compression en cours
    }
    return status_emojis.get(status, '‚ùì')

def safe_int(value, default=0):
    """
    Conversion s√©curis√©e en entier
    
    Args:
        value: Valeur √† convertir
        default (int): Valeur par d√©faut si conversion impossible
        
    Returns:
        int: Valeur convertie ou valeur par d√©faut
    """
    try:
        return int(value) if value is not None else default
    except (ValueError, TypeError):
        return default

def safe_float(value, default=0.0):
    """
    Conversion s√©curis√©e en float
    
    Args:
        value: Valeur √† convertir
        default (float): Valeur par d√©faut si conversion impossible
        
    Returns:
        float: Valeur convertie ou valeur par d√©faut
    """
    try:
        return float(value) if value is not None else default
    except (ValueError, TypeError):
        return default

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                           SECTION 3: BASE DE DONN√âES                      ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def create_tables():
    """
    Initialise la base de donn√©es SQLite avec les tables n√©cessaires
    
    Tables cr√©√©es:
    - torrents: Informations de base des torrents
    - torrent_details: D√©tails complets des torrents
    - sync_progress: Progression des synchronisations (pour reprise)
    """
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # Table principale des torrents (informations de base)
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS torrents (
            id TEXT PRIMARY KEY,
            filename TEXT,
            status TEXT,
            bytes INTEGER,
            added_on TEXT
        )
    ''')
    
    # Table des d√©tails complets
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS torrent_details (
            id TEXT PRIMARY KEY,
            name TEXT,
            status TEXT,
            size INTEGER,
            files_count INTEGER,
            progress INTEGER,
            links TEXT,
            hash TEXT,
            host TEXT,
            error TEXT,
            FOREIGN KEY (id) REFERENCES torrents (id)
        )
    ''')
    
    # Table pour la reprise des synchronisations
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS sync_progress (
            id INTEGER PRIMARY KEY,
            operation TEXT,
            total_items INTEGER,
            processed_items INTEGER,
            last_processed_id TEXT,
            start_time TEXT,
            status TEXT
        )
    ''')
    
    # Index pour optimiser les performances
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_torrents_status ON torrents(status)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_torrents_added ON torrents(added_on)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_details_status ON torrent_details(status)')
    
    conn.commit()
    conn.close()
    logging.info("Base de donn√©es initialis√©e avec succ√®s")

def get_db_stats():
    """
    R√©cup√®re les statistiques de base de la base de donn√©es
    
    Returns:
        tuple: (total_torrents, total_details, coverage_percent)
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    # Compte total des torrents
    cursor.execute("SELECT COUNT(*) FROM torrents")
    total_torrents = cursor.fetchone()[0]
    
    # Compte des d√©tails disponibles
    cursor.execute("SELECT COUNT(*) FROM torrent_details")
    total_details = cursor.fetchone()[0]
    
    conn.close()
    
    coverage = (total_details / total_torrents * 100) if total_torrents > 0 else 0
    return total_torrents, total_details, coverage

def clear_database():
    """
    Vide compl√®tement la base de donn√©es apr√®s confirmation
    
    Supprime toutes les donn√©es des tables tout en conservant la structure.
    Op√©ration irr√©versible, demande confirmation explicite.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    
    cursor.execute("DELETE FROM sync_progress")
    cursor.execute("DELETE FROM torrent_details")
    cursor.execute("DELETE FROM torrents")
    
    # Reset des auto-increment
    cursor.execute("DELETE FROM sqlite_sequence WHERE name IN ('torrents', 'torrent_details', 'sync_progress')")
    
    conn.commit()
    conn.close()
    
    logging.info("Base de donn√©es vid√©e avec succ√®s")
    print("‚úÖ Base de donn√©es compl√®tement vid√©e")

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                           SECTION 4: API REAL-DEBRID                      ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def load_token():
    """
    R√©cup√®re le token Real-Debrid avec nettoyage et validation maximum
    G√®re tous les cas d'erreurs possibles pour √©viter Header Injection
    
    Priorit√© de recherche:
    1. Variable d'environnement RD_TOKEN
    2. Fichier config/rd_token.conf
    3. Fichier .env (fallback)
    
    Returns:
        str: Token Real-Debrid valide et nettoy√©
        
    Raises:
        SystemExit: Si aucun token valide trouv√©
    """
    import re
    
    def clean_token(raw_token):
        """Nettoie un token de tous les caract√®res parasites"""
        if not raw_token:
            return None
            
        # √âtape 1 : Conversion en string et suppression des espaces
        token = str(raw_token).strip()
        
        # √âtape 2 : Suppression de tous les caract√®res de contr√¥le
        token = re.sub(r'[\r\n\t\f\v]', '', token)
        
        # √âtape 3 : Suppression des espaces multiples
        token = re.sub(r'\s+', '', token)
        
        # √âtape 4 : Validation format (seuls alphanum√©riques, tirets, underscores)
        if not re.match(r'^[A-Za-z0-9_-]+$', token):
            return None
            
        # √âtape 5 : Validation longueur (tokens RD font g√©n√©ralement 40-60 caract√®res)
        if len(token) < 20 or len(token) > 100:
            return None
            
        return token
    
    def extract_token_from_file(filepath):
        """Extrait le token d'un fichier en ignorant commentaires et lignes vides"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # Ignorer les lignes vides et les commentaires
                    if line and not line.startswith('#'):
                        # Prendre la premi√®re ligne valide trouv√©e
                        cleaned = clean_token(line)
                        if cleaned:
                            return cleaned
            return None
        except (FileNotFoundError, PermissionError, UnicodeDecodeError):
            return None
    
    # Chargement des variables d'environnement
    load_env_file()
    
    # Tentative 1 : Variable d'environnement RD_TOKEN
    env_token = os.environ.get("RD_TOKEN")
    if env_token:
        cleaned_env = clean_token(env_token)
        if cleaned_env:
            logging.debug("‚úÖ Token r√©cup√©r√© depuis variable d'environnement")
            return cleaned_env
        else:
            logging.warning("‚ö†Ô∏è  Variable RD_TOKEN contient un token invalide")
    
    # Tentative 2 : Fichier config/rd_token.conf
    config_path = os.path.join(os.path.dirname(__file__), "../config/rd_token.conf")
    config_token = extract_token_from_file(config_path)
    if config_token:
        logging.debug("‚úÖ Token r√©cup√©r√© depuis config/rd_token.conf")
        return config_token
    
    # Tentative 3 : Fichier .env (secours)
    env_file_token = None
    try:
        with open('.env', 'r') as f:
            for line in f:
                if line.strip().startswith('RD_TOKEN='):
                    env_file_token = line.split('=', 1)[1]
                    break
        
        if env_file_token:
            cleaned_env_file = clean_token(env_file_token)
            if cleaned_env_file:
                logging.debug("‚úÖ Token r√©cup√©r√© depuis fichier .env")
                return cleaned_env_file
    except FileNotFoundError:
        pass
    
    # Aucun token valide trouv√©
    logging.error("‚ùå Aucun token Real-Debrid valide trouv√©")
    logging.error("üí° Veuillez configurer votre token :")
    logging.error("   ‚Ä¢ Variable : export RD_TOKEN='votre_token'")
    logging.error("   ‚Ä¢ Fichier  : echo -n 'votre_token' > config/rd_token.conf")
    
    sys.exit(1)

async def api_request(session, url, headers, params=None, max_retries=3):
    """
    Fonction g√©n√©rique pour les appels API Real-Debrid avec gestion d'erreurs compl√®te
    
    Features:
    - Retry automatique avec backoff exponentiel
    - Gestion des quotas API (429)
    - Gestion des erreurs d'authentification
    - Support interruption propre (CTRL+C)
    
    Args:
        session: Session aiohttp
        url (str): URL de l'API
        headers (dict): Headers incluant l'authentification
        params (dict, optional): Param√®tres de requ√™te
        max_retries (int): Nombre maximum de tentatives
        
    Returns:
        dict/None: R√©ponse JSON ou None en cas d'erreur
    """
    for attempt in range(max_retries):
        if stop_requested:
            return None
        try:
            async with session.get(url, headers=headers, params=params) as resp:
                # Gestion des erreurs d'authentification
                if resp.status == 401 or resp.status == 403:
                    logging.error("Token Real-Debrid invalide ou expir√©.")
                    sys.exit(1)
                
                # Torrent non trouv√© (normal dans certains cas)
                if resp.status == 404:
                    return None
                
                # Gestion du quota API
                if resp.status == 429:
                    wait_time = QUOTA_WAIT_TIME if params else TORRENT_QUOTA_WAIT
                    logging.warning(f"Quota API d√©pass√©, attente {wait_time}s...")
                    await asyncio.sleep(wait_time)
                    continue
                
                resp.raise_for_status()
                return await resp.json()
                
        except Exception as e:
            if attempt == max_retries - 1:
                logging.error(f"Erreur API apr√®s {max_retries} tentatives: {e}")
                return None
            # Backoff exponentiel
            await asyncio.sleep(2 ** attempt)
    return None

async def fetch_all_torrents(token):
    """
    R√©cup√®re tous les torrents depuis l'API Real-Debrid
    
    Utilise la pagination pour r√©cup√©rer tous les torrents par batches de 1000.
    Sauvegarde directement en base pour √©viter la surcharge m√©moire.
    
    Args:
        token (str): Token d'authentification Real-Debrid
        
    Returns:
        int: Nombre total de torrents r√©cup√©r√©s
    """
    headers = {"Authorization": f"Bearer {token}"}
    limit = 1000
    page = 1
    total = 0
    
    async with aiohttp.ClientSession() as session:
        while True:
            if stop_requested:
                logging.info("Arr√™t demand√©, interruption de la r√©cup√©ration des torrents.")
                break
                
            params = {"page": page, "limit": limit}
            torrents = await api_request(session, RD_API_URL, headers, params)
            
            if not torrents:
                break
                
            # Sauvegarde imm√©diate en base
            for t in torrents:
                upsert_torrent(t)
                
            total += len(torrents)
            logging.info(f"Page {page}: {len(torrents)} torrents (total: {total})")
            page += 1
            
    return total

async def fetch_torrent_detail(session, token, torrent_id):
    """
    R√©cup√®re les d√©tails complets d'un torrent sp√©cifique
    
    Args:
        session: Session aiohttp
        token (str): Token d'authentification
        torrent_id (str): ID du torrent
        
    Returns:
        dict/None: D√©tails du torrent ou None si erreur
    """
    url = f"https://api.real-debrid.com/rest/1.0/torrents/info/{torrent_id}"
    headers = {"Authorization": f"Bearer {token}"}
    
    detail = await api_request(session, url, headers)
    if detail:
        logging.debug(f"D√©tail r√©cup√©r√© pour {torrent_id}")
        upsert_torrent_detail(detail)
    return detail

def upsert_torrent(t):
    """
    Insert ou met √† jour un torrent dans la table torrents
    
    Args:
        t (dict): Donn√©es du torrent depuis l'API
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute('''INSERT OR REPLACE INTO torrents (id, filename, status, bytes, added_on)
            VALUES (?, ?, ?, ?, ?)''',
            (t.get('id'), t.get('filename'), t.get('status'), t.get('bytes'), t.get('added'))
        )
        conn.commit()

def upsert_torrent_detail(detail):
    """
    Insert ou met √† jour les d√©tails d'un torrent dans la table torrent_details
    
    Args:
        detail (dict): D√©tails du torrent depuis l'API
    """
    if not detail or not detail.get('id'):
        return
        
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute('''INSERT OR REPLACE INTO torrent_details
            (id, name, status, size, files_count, progress, links, hash, host, error)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
            (
                detail.get('id'),
                detail.get('filename') or detail.get('name'),
                detail.get('status'),
                detail.get('bytes'),
                len(detail.get('files', [])),
                detail.get('progress'),
                ",".join(detail.get('links', [])) if detail.get('links') else None,
                detail.get('hash'),
                detail.get('host'),
                detail.get('error')
            )
        )
        conn.commit()

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                         SECTION 5: SYNCHRONISATION                        ‚ïë  
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

class DynamicRateLimiter:
    """
    Contr√¥leur dynamique de concurrence pour optimiser les performances API
    
    Ajuste automatiquement le nombre de requ√™tes simultan√©es selon:
    - Taux de succ√®s/√©chec
    - Performance g√©n√©rale
    - Respect des quotas API
    
    Attributes:
        concurrent (int): Nombre actuel de requ√™tes simultan√©es
        max_concurrent (int): Limite maximale
        success_count (int): Compteur de succ√®s
        error_count (int): Compteur d'erreurs
    """
    
    def __init__(self, initial_concurrent=20, max_concurrent=80):
        self.concurrent = initial_concurrent
        self.max_concurrent = max_concurrent
        self.success_count = 0
        self.error_count = 0
        self.last_adjustment = time.time()
        
    def adjust_concurrency(self, success=True):
        """
        Ajuste la concurrence selon les r√©sultats
        
        Args:
            success (bool): True si la derni√®re requ√™te a r√©ussi
        """
        if success:
            self.success_count += 1
        else:
            self.error_count += 1
            
        # Ajustement p√©riodique ou apr√®s un seuil
        if (self.success_count + self.error_count) % 50 == 0 or time.time() - self.last_adjustment > 30:
            error_rate = self.error_count / max(1, self.success_count + self.error_count)
            
            # Augmenter si peu d'erreurs
            if error_rate < 0.05:
                self.concurrent = min(self.max_concurrent, int(self.concurrent * 1.2))
                logging.info(f"üìà Concurrence augment√©e √† {self.concurrent}")
            # R√©duire si trop d'erreurs
            elif error_rate > 0.15:
                self.concurrent = max(5, int(self.concurrent * 0.7))
                logging.info(f"üìâ Concurrence r√©duite √† {self.concurrent}")
                
            self.last_adjustment = time.time()
            self.success_count = self.error_count = 0
            
    def get_semaphore(self):
        """Retourne un semaphore avec la concurrence actuelle"""
        return asyncio.Semaphore(self.concurrent)

def save_progress(processed_ids, filename="data/sync_progress.json"):
    """
    Sauvegarde la progression d'une synchronisation pour reprise ult√©rieure
    
    Args:
        processed_ids (set): IDs des torrents d√©j√† trait√©s
        filename (str): Chemin du fichier de sauvegarde
    """
    os.makedirs(os.path.dirname(filename), exist_ok=True)
    with open(filename, 'w') as f:
        json.dump({
            'processed_ids': list(processed_ids),
            'timestamp': time.time()
        }, f)

def load_progress(filename="data/sync_progress.json"):
    """
    Charge la progression d'une synchronisation pr√©c√©dente
    
    Args:
        filename (str): Chemin du fichier de sauvegarde
        
    Returns:
        set: IDs des torrents d√©j√† trait√©s (max 6h d'anciennet√©)
    """
    try:
        with open(filename, 'r') as f:
            data = json.load(f)
            # Ignorer si plus de 6 heures
            if time.time() - data['timestamp'] < 21600:
                return set(data['processed_ids'])
    except:
        pass
    return set()

async def fetch_all_torrent_details_v2(token, torrent_ids, resumable=False):
    """
    Version optimis√©e pour r√©cup√©rer les d√©tails de torrents (sync-fast et sync-smart)
    
    Features:
    - Contr√¥le dynamique de la concurrence
    - Reprise possible des synchronisations interrompues
    - Pool de connexions optimis√©
    - Statistiques temps r√©el
    - Sauvegarde progressive
    
    Args:
        token (str): Token Real-Debrid
        torrent_ids (list): Liste des IDs √† traiter
        resumable (bool): Si True, permet la reprise
        
    Returns:
        int: Nombre de d√©tails trait√©s avec succ√®s
    """
    # Gestion de la reprise
    if resumable:
        processed_ids = load_progress()
        remaining_ids = [tid for tid in torrent_ids if tid not in processed_ids]
        if processed_ids:
            logging.info(f"üìÇ Reprise: {len(processed_ids)} d√©j√† trait√©s, {len(remaining_ids)} restants")
    else:
        remaining_ids = torrent_ids
        processed_ids = set()
    
    if not remaining_ids:
        logging.info("‚úÖ Tous les d√©tails sont √† jour !")
        return len(processed_ids)
    
    rate_limiter = DynamicRateLimiter()
    total_processed = len(processed_ids)
    start_time = time.time()
    
    # Pool de connexions optimis√©
    connector = aiohttp.TCPConnector(limit=100, limit_per_host=50, keepalive_timeout=30)
    timeout = aiohttp.ClientTimeout(total=15, connect=5)
    
    async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
        
        async def process_torrent_optimized(tid):
            """Traite un torrent avec contr√¥le de concurrence dynamique"""
            semaphore = rate_limiter.get_semaphore()
            async with semaphore:
                result = await fetch_torrent_detail(session, token, tid)
                success = result is not None
                rate_limiter.adjust_concurrency(success)
                
                if success:
                    nonlocal total_processed
                    total_processed += 1
                    processed_ids.add(tid)
                    
                    # Stats temps r√©el + sauvegarde p√©riodique
                    if total_processed % 100 == 0:
                        elapsed = time.time() - start_time
                        rate = (total_processed - len(processed_ids)) / elapsed if elapsed > 0 else 0
                        remaining = len(torrent_ids) - total_processed
                        eta = remaining / rate if rate > 0 else 0
                        
                        logging.info(f"üìä {total_processed}/{len(torrent_ids)} | "
                                   f"{rate:.1f}/s | ETA: {eta/60:.1f}min | "
                                   f"Concurrence: {rate_limiter.concurrent}")
                        
                        if resumable:
                            save_progress(processed_ids)
                
                return result
        
        # Traitement par chunks adaptatifs
        chunk_size = min(300, len(remaining_ids))
        for i in range(0, len(remaining_ids), chunk_size):
            if stop_requested:
                break
                
            chunk_ids = remaining_ids[i:i+chunk_size]
            tasks = [process_torrent_optimized(tid) for tid in chunk_ids]
            
            await asyncio.gather(*tasks, return_exceptions=True)
            
            # Pause adaptative entre chunks
            if i + chunk_size < len(remaining_ids):
                pause = max(3, 20 - rate_limiter.concurrent * 0.2)
                logging.info(f"‚è∏Ô∏è  Pause {pause:.1f}s...")
                await asyncio.sleep(pause)
    
    elapsed = time.time() - start_time
    processed_new = total_processed - len(set(processed_ids) - processed_ids)
    logging.info(f"üéâ Termin√© ! {processed_new} nouveaux d√©tails en {elapsed/60:.1f}min "
                 f"({processed_new/elapsed:.1f} torrents/s)")
    
    # Nettoyer le fichier de progression si termin√©
    if resumable and os.path.exists("data/sync_progress.json"):
        os.remove("data/sync_progress.json")
    
    return total_processed

def sync_all(token):
    """
    Synchronisation compl√®te classique (version originale)
    
    √âtapes:
    1. R√©cup√®re tous les torrents de base
    2. R√©cup√®re tous les d√©tails
    
    Usage: Pour premi√®re synchronisation compl√®te
    Temps estim√©: 4-6 heures pour 4000+ torrents
    """
    logging.info("üì• Synchronisation compl√®te classique...")
    
    # √âtape 1: Tous les torrents
    total = asyncio.run(fetch_all_torrents(token))
    logging.info(f"‚úÖ {total} torrents r√©cup√©r√©s")
    
    # √âtape 2: Tous les d√©tails
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT id FROM torrents")
        torrent_ids = [row[0] for row in c.fetchall()]
    
    logging.info(f"üîÑ R√©cup√©ration des d√©tails pour {len(torrent_ids)} torrents...")
    processed = asyncio.run(fetch_all_torrent_details(token, torrent_ids))
    logging.info(f"‚úÖ Synchronisation compl√®te termin√©e ! {processed} d√©tails trait√©s")

def sync_all_v2(token):
    """
    Synchronisation rapide optimis√©e (sync-fast)
    
    Version am√©lior√©e de sync_all avec:
    - Contr√¥le dynamique de concurrence
    - Pool de connexions optimis√©
    - Reprise automatique possible
    - Statistiques temps r√©el
    
    Usage: Synchronisation compl√®te optimis√©e
    Temps estim√©: 7-10 minutes pour 4000+ torrents
    """
    logging.info("üöÄ Synchronisation rapide d√©marr√©e...")
    
    # √âtape 1: R√©cup√©rer tous les torrents (identique)
    total = asyncio.run(fetch_all_torrents(token))
    logging.info(f"‚úÖ {total} torrents synchronis√©s")
    
    # √âtape 2: R√©cup√©ration optimis√©e des d√©tails
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT id FROM torrents")
        torrent_ids = [row[0] for row in c.fetchall()]
    
    logging.info(f"üîÑ R√©cup√©ration optimis√©e des d√©tails pour {len(torrent_ids)} torrents...")
    processed = asyncio.run(fetch_all_torrent_details_v2(token, torrent_ids, resumable=True))
    logging.info(f"üéØ Synchronisation rapide termin√©e ! {processed} d√©tails trait√©s")

def get_smart_update_summary():
    """
    Analyse intelligente des torrents n√©cessitant une mise √† jour
    
    Cat√©gories analys√©es:
    - Nouveaux torrents sans d√©tails
    - T√©l√©chargements actifs
    - Torrents en erreur (retry)
    - Torrents anciens (>7 jours)
    
    Returns:
        dict: R√©sum√© des changements d√©tect√©s
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        
        # Nouveaux torrents (pas de d√©tails)
        c.execute('''
            SELECT COUNT(*) FROM torrents t
            LEFT JOIN torrent_details td ON t.id = td.id
            WHERE td.id IS NULL
        ''')
        new_count = c.fetchone()[0]
        
        # T√©l√©chargements actifs
        c.execute('''
            SELECT COUNT(*) FROM torrent_details
            WHERE status IN ('downloading', 'queued', 'waiting_files_selection')
        ''')
        active_count = c.fetchone()[0]
        
        # Torrents en erreur (pour retry)
        c.execute('''
            SELECT COUNT(*) FROM torrent_details
            WHERE status = 'error' OR error IS NOT NULL
        ''')
        error_count = c.fetchone()[0]
        
        # Torrents anciens (plus de 7 jours sans mise √† jour)
        c.execute('''
            SELECT COUNT(*) FROM torrents t
            LEFT JOIN torrent_details td ON t.id = td.id
            WHERE datetime('now') - datetime(t.added_on) > 7
        ''')
        old_count = c.fetchone()[0]
        
        return {
            'new_torrents': new_count,
            'active_downloads': active_count,
            'error_retry': error_count,
            'old_updates': old_count
        }

def get_torrents_needing_update():
    """
    Identifie les torrents n√©cessitant une mise √† jour pour sync-smart
    
    Crit√®res:
    - Nouveaux torrents sans d√©tails
    - T√©l√©chargements actifs (downloading, queued, etc.)
    - Torrents en erreur (retry automatique)
    - Torrents anciens (>7 jours)
    
    Returns:
        list: Liste des IDs de torrents √† mettre √† jour
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute('''
            SELECT t.id FROM torrents t
            LEFT JOIN torrent_details td ON t.id = td.id
            WHERE td.id IS NULL 
               OR (td.status IN ('downloading', 'queued', 'waiting_files_selection'))
               OR (td.status = 'error' OR td.error IS NOT NULL)
               OR datetime('now') - datetime(t.added_on) > 7
        ''')
        return [row[0] for row in c.fetchall()]

def sync_smart(token):
    """
    Synchronisation intelligente - Mode recommand√© pour usage quotidien
    
    Fonctionnalit√©s:
    - ‚úÖ D√©tecte uniquement les changements n√©cessaires
    - ‚úÖ Retry automatique des torrents en erreur  
    - ‚úÖ Analyse pr√©-sync avec r√©sum√© d√©taill√©
    - ‚úÖ Performance optimis√©e (15-50 torrents/s)
    - ‚úÖ R√©sum√© post-sync avec recommandations
    
    Usage: python src/main.py --sync-smart
    Temps typique: 30s - 2 minutes
    """
    logging.info("üß† Synchronisation intelligente d√©marr√©e...")
    
    # Analyser les changements avant de commencer
    summary = get_smart_update_summary()
    
    # Afficher le r√©sum√© des changements d√©tect√©s
    logging.info("üìä Analyse des changements :")
    if summary['new_torrents'] > 0:
        logging.info(f"   üÜï Nouveaux torrents sans d√©tails : {summary['new_torrents']}")
    if summary['active_downloads'] > 0:
        logging.info(f"   ‚¨áÔ∏è  T√©l√©chargements actifs : {summary['active_downloads']}")
    if summary['error_retry'] > 0:
        logging.info(f"   üîÑ Torrents en erreur (retry) : {summary['error_retry']}")
    if summary['old_updates'] > 0:
        logging.info(f"   üìÖ Torrents anciens (>7j) : {summary['old_updates']}")
    
    # Obtenir la liste des torrents √† mettre √† jour
    torrent_ids = get_torrents_needing_update()
    
    if not torrent_ids:
        logging.info("‚úÖ Rien √† synchroniser, tout est √† jour !")
        return
    
    total_changes = len(torrent_ids)
    logging.info(f"üéØ Total : {total_changes} torrents n√©cessitent une mise √† jour")
    
    # Traiter les mises √† jour avec mesure du temps
    start_time = time.time()
    processed = asyncio.run(fetch_all_torrent_details_v2(token, torrent_ids))
    end_time = time.time()
    
    # Statistiques finales
    duration = end_time - start_time
    rate = processed / duration if duration > 0 else 0
    
    logging.info(f"‚úÖ Synchronisation intelligente termin√©e !")
    logging.info(f"   üìä {processed} d√©tails mis √† jour en {duration:.1f}s ({rate:.1f}/s)")
    
    # Afficher un r√©sum√© final
    display_final_summary()

def sync_resume(token):
    """
    Reprendre une synchronisation interrompue √† partir du point d'arr√™t
    
    Utilise les fichiers de progression sauvegard√©s pour reprendre
    exactement l√† o√π la synchronisation s'√©tait arr√™t√©e.
    
    Usage: python src/main.py --resume
    """
    logging.info("‚èÆÔ∏è  Reprise de synchronisation...")
    
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        c.execute("SELECT id FROM torrents")
        all_ids = [row[0] for row in c.fetchall()]
    
    processed = asyncio.run(fetch_all_torrent_details_v2(token, all_ids, resumable=True))
    logging.info(f"‚úÖ Reprise termin√©e ! {processed} d√©tails trait√©s")

def sync_details_only(token, status_filter=None):
    """
    Synchronise uniquement les d√©tails des torrents existants en base
    
    Args:
        token (str): Token Real-Debrid
        status_filter (str, optional): Filtre par statut (error, downloading, etc.)
        
    Usage:
        - python src/main.py --details-only
        - python src/main.py --details-only --status error
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        query = "SELECT id FROM torrents"
        params = ()
        if status_filter:
            query += " WHERE status = ?"
            params = (status_filter,)
        c.execute(query, params)
        torrent_ids = [row[0] for row in c.fetchall()]
    
    if not torrent_ids:
        logging.info("Aucun torrent trouv√© pour synchronisation des d√©tails.")
        return
        
    logging.info(f"üîÑ Synchronisation des d√©tails pour {len(torrent_ids)} torrents...")
    processed = asyncio.run(fetch_all_torrent_details(token, torrent_ids))
    logging.info(f"‚úÖ D√©tails synchronis√©s pour {processed} torrents.")

def sync_torrents_only(token):
    """
    Synchronisation ultra-rapide des torrents de base uniquement (sans d√©tails)
    
    Parfait pour:
    - Vue d'ensemble rapide de la collection
    - Premi√®re d√©couverte avant sync complet
    - Monitoring des nouveaux ajouts
    
    Usage: python src/main.py --torrents-only
    Temps typique: 10-30 secondes
    """
    logging.info("üìã Synchronisation des torrents de base uniquement...")
    
    total = asyncio.run(fetch_all_torrents(token))
    
    if total > 0:
        logging.info(f"‚úÖ Synchronisation termin√©e ! {total} torrents enregistr√©s dans la table 'torrents'")
        
        # Afficher un petit r√©sum√©
        with sqlite3.connect(DB_PATH) as conn:
            c = conn.cursor()
            c.execute("SELECT status, COUNT(*) FROM torrents GROUP BY status")
            status_counts = dict(c.fetchall())
            
            print(f"\nüìä R√©sum√© des torrents synchronis√©s:")
            for status, count in status_counts.items():
                emoji = get_status_emoji(status)
                print(f"   {emoji} {status}: {count}")
    else:
        logging.info("‚ÑπÔ∏è  Aucun torrent trouv√© ou synchronis√©")

async def fetch_all_torrent_details(token, torrent_ids, max_concurrent=MAX_CONCURRENT):
    """
    Version classique de r√©cup√©ration des d√©tails (pour compatibilit√©)
    
    Args:
        token (str): Token Real-Debrid
        torrent_ids (list): IDs des torrents √† traiter
        max_concurrent (int): Nombre de requ√™tes simultan√©es
        
    Returns:
        int: Nombre de d√©tails trait√©s
    """
    semaphore = asyncio.Semaphore(max_concurrent)
    total_processed = 0
    
    async with aiohttp.ClientSession() as session:
        async def process_torrent(tid):
            async with semaphore:
                return await fetch_torrent_detail(session, token, tid)
        
        # Traitement par batch pour respecter les quotas
        for i in range(0, len(torrent_ids), BATCH_SIZE):
            if stop_requested:
                logging.info("Arr√™t demand√©, interruption de la r√©cup√©ration des d√©tails.")
                break
                
            batch_ids = torrent_ids[i:i+BATCH_SIZE]
            tasks = [process_torrent(tid) for tid in batch_ids]
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Compter les succ√®s
            successful = sum(1 for r in batch_results if r and not isinstance(r, Exception))
            total_processed += successful
            
            logging.info(f"Batch {i//BATCH_SIZE + 1}: {successful}/{len(batch_ids)} d√©tails r√©cup√©r√©s")
            
            # Pause entre les batches sauf pour le dernier
            if i + BATCH_SIZE < len(torrent_ids):
                logging.info(f"Pause {QUOTA_WAIT_TIME}s avant le prochain batch...")
                await asyncio.sleep(QUOTA_WAIT_TIME)
    
    return total_processed

def display_final_summary():
    """
    Affiche un r√©sum√© final apr√®s synchronisation avec recommandations
    
    Informations affich√©es:
    - Statistiques g√©n√©rales
    - R√©partition par statut
    - Activit√© r√©cente
    - Recommandations d'actions
    """
    try:
        with sqlite3.connect(DB_PATH) as conn:
            c = conn.cursor()
            
            # Statistiques g√©n√©rales
            c.execute("SELECT COUNT(*) FROM torrents")
            total_torrents = c.fetchone()[0]
            
            c.execute("SELECT COUNT(*) FROM torrent_details")
            total_details = c.fetchone()[0]
            
            # R√©partition par statut (top 5)
            c.execute("""
                SELECT COALESCE(td.status, t.status, 'inconnu') as status, COUNT(*) as count
                FROM torrents t
                LEFT JOIN torrent_details td ON t.id = td.id
                GROUP BY COALESCE(td.status, t.status)
                ORDER BY count DESC
                LIMIT 5
            """)
            status_counts = c.fetchall()
            
            # Torrents r√©cents (derni√®res 24h)
            c.execute("""
                SELECT COUNT(*) FROM torrents 
                WHERE datetime('now') - datetime(added_on) < 1
            """)
            recent_count = c.fetchone()[0]
            
            print(f"\nüìä R√©sum√© de la base de donn√©es :")
            print(f"   üìÇ Total torrents : {total_torrents}")
            print(f"   üìù Avec d√©tails : {total_details} ({100*total_details/total_torrents:.1f}%)")
            print(f"   üÜï Ajout√©s r√©cemment (24h) : {recent_count}")
            
            if status_counts:
                print(f"\nüìà Top 5 des statuts :")
                for status, count in status_counts:
                    percentage = 100 * count / total_torrents if total_torrents > 0 else 0
                    emoji = get_status_emoji(status)
                    print(f"   {emoji} {status} : {count} ({percentage:.1f}%)")
                    
    except Exception as e:
        logging.warning(f"Impossible d'afficher le r√©sum√© : {e}")

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                      SECTION 6: STATISTIQUES ET ANALYTICS                 ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def show_stats():
    """
    Affiche des statistiques compl√®tes et d√©taill√©es de votre collection
    
    Sections d'analyse:
    - üóÇÔ∏è Vue d'ensemble g√©n√©rale
    - üíæ Volumes de donn√©es  
    - ‚è∞ Activit√© r√©cente
    - üîÑ √âtat des t√©l√©chargements
    - üìà R√©partition par statut
    - üåê Top h√©bergeurs
    - üèÜ Plus gros torrents
    - üí° Recommandations automatiques
    
    Usage: python src/main.py --stats
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        
        # === STATISTIQUES G√âN√âRALES ===
        c.execute("SELECT COUNT(*) FROM torrents")
        total_torrents = c.fetchone()[0]
        
        c.execute("SELECT COUNT(*) FROM torrent_details")
        total_details = c.fetchone()[0]
        
        coverage_percent = (total_details / total_torrents * 100) if total_torrents > 0 else 0
        
        # === R√âPARTITION PAR STATUT ===
        c.execute("SELECT status, COUNT(*) FROM torrents GROUP BY status ORDER BY COUNT(*) DESC")
        torrent_status = c.fetchall()
        
        c.execute("SELECT status, COUNT(*) FROM torrent_details GROUP BY status ORDER BY COUNT(*) DESC")
        detail_status = c.fetchall()
        
        # === TAILLES ET VOLUMES ===
        c.execute("SELECT SUM(bytes), AVG(bytes), MIN(bytes), MAX(bytes) FROM torrents WHERE bytes > 0")
        size_stats = c.fetchone()
        total_size, avg_size, min_size, max_size = size_stats if size_stats and size_stats[0] else (0, 0, 0, 0)
        
        # === ACTIVIT√â R√âCENTE ===
        c.execute("""
            SELECT COUNT(*) FROM torrents 
            WHERE datetime(added_on) >= datetime('now', '-24 hours')
        """)
        recent_24h = c.fetchone()[0] or 0
        
        c.execute("""
            SELECT COUNT(*) FROM torrents 
            WHERE datetime(added_on) >= datetime('now', '-7 days')
        """)
        recent_7d = c.fetchone()[0] or 0
        
        # === TORRENTS PROBL√âMATIQUES ===
        c.execute("SELECT COUNT(*) FROM torrent_details WHERE status = 'error' OR error IS NOT NULL")
        error_count = c.fetchone()[0] or 0
        
        c.execute("SELECT COUNT(*) FROM torrent_details WHERE status IN ('downloading', 'queued', 'waiting_files_selection')")
        active_count = c.fetchone()[0] or 0
        
        # === TORRENTS SANS D√âTAILS ===
        c.execute("""
            SELECT COUNT(*) FROM torrents t 
            LEFT JOIN torrent_details td ON t.id = td.id 
            WHERE td.id IS NULL
        """)
        missing_details = c.fetchone()[0] or 0
        
        # === TOP H√âBERGEURS ===
        c.execute("""
            SELECT host, COUNT(*) as count 
            FROM torrent_details 
            WHERE host IS NOT NULL AND host != ''
            GROUP BY host 
            ORDER BY count DESC 
            LIMIT 5
        """)
        top_hosts = c.fetchall()
        
        # === TORRENTS LES PLUS GROS ===
        c.execute("""
            SELECT name, size, status 
            FROM torrent_details 
            WHERE size > 0 AND name IS NOT NULL
            ORDER BY size DESC 
            LIMIT 5
        """)
        biggest_torrents = c.fetchall()
        
        # === PROGRESSION MOYENNE ===
        c.execute("SELECT AVG(progress) FROM torrent_details WHERE progress IS NOT NULL")
        avg_progress = c.fetchone()[0] or 0
        
        # === AFFICHAGE FORMAT√â ===
        print("\n" + "="*60)
        print("üìä STATISTIQUES COMPL√àTES REDRIVA")
        print("="*60)
        
        # Vue d'ensemble
        print(f"\nüóÇÔ∏è  VUE D'ENSEMBLE")
        print(f"   üìÅ Total torrents     : {total_torrents:,}")
        print(f"   üìã D√©tails disponibles: {total_details:,}")
        print(f"   üìä Couverture         : {coverage_percent:.1f}%")
        print(f"   ‚ùå D√©tails manquants  : {missing_details:,}")
        
        # Volumes de donn√©es
        if total_size and total_size > 0:
            print(f"\nüíæ VOLUMES DE DONN√âES")
            print(f"   üì¶ Volume total       : {format_size(total_size)}")
            print(f"   üìä Taille moyenne     : {format_size(avg_size) if avg_size else 'N/A'}")
            print(f"   üîª Plus petit         : {format_size(min_size) if min_size else 'N/A'}")
            print(f"   üî∫ Plus gros          : {format_size(max_size) if max_size else 'N/A'}")
        
        # Activit√© r√©cente
        print(f"\n‚è∞ ACTIVIT√â R√âCENTE")
        print(f"   üÜï Derni√®res 24h      : {recent_24h:,} torrents")
        print(f"   üìÖ Derniers 7 jours   : {recent_7d:,} torrents")
        
        # √âtat des t√©l√©chargements
        print(f"\nüîÑ √âTAT DES T√âL√âCHARGEMENTS")
        print(f"   ‚úÖ Progression moyenne: {avg_progress:.1f}%")
        print(f"   ‚¨áÔ∏è  T√©l√©chargements    : {active_count:,}")
        print(f"   ‚ùå Erreurs            : {error_count:,}")
        
        # R√©partition par statut (torrents)
        if torrent_status:
            print(f"\nüìà R√âPARTITION PAR STATUT")
            for status, count in torrent_status[:8]:  # Top 8
                percent = (count / total_torrents * 100) if total_torrents > 0 else 0
                status_emoji = get_status_emoji(status)
                print(f"   {status_emoji} {status:<15} : {count:,} ({percent:.1f}%)")
        
        # Top h√©bergeurs
        if top_hosts:
            print(f"\nüåê TOP H√âBERGEURS")
            for host, count in top_hosts:
                percent = (count / total_details * 100) if total_details > 0 else 0
                print(f"   üîó {host:<15} : {count:,} ({percent:.1f}%)")
        
        # Plus gros torrents
        if biggest_torrents:
            print(f"\nüèÜ TOP 5 PLUS GROS TORRENTS")
            for i, (name, size, status) in enumerate(biggest_torrents, 1):
                status_emoji = get_status_emoji(status)
                truncated_name = (name[:45] + "...") if len(name) > 48 else name
                print(f"   {i}. {status_emoji} {format_size(size)} - {truncated_name}")
        
        # Recommandations automatiques
        print(f"\nüí° RECOMMANDATIONS")
        if missing_details > 0:
            print(f"   üîß Ex√©cuter: python src/main.py --sync-smart")
            print(f"      (pour r√©cup√©rer {missing_details:,} d√©tails manquants)")
        
        if error_count > 0:
            print(f"   üîÑ Ex√©cuter: python src/main.py --details-only --status error")
            print(f"      (pour retry {error_count:,} torrents en erreur)")
        
        if active_count > 0:
            print(f"   ‚¨áÔ∏è  {active_count:,} t√©l√©chargements en cours")
            print(f"      (utilisez --sync-smart pour les suivre)")
        
        if missing_details == 0 and error_count == 0:
            print(f"   ‚úÖ Votre base est compl√®te et √† jour !")
        
        print("\n" + "="*60)

def show_stats_compact():
    """
    Version compacte des statistiques sur une ligne pour usage fr√©quent
    
    Parfait pour:
    - Monitoring quotidien rapide
    - Scripts automatis√©s
    - Check rapide avant sync
    
    Usage: python src/main.py --stats --compact
    Exemple: üìä 4,233 torrents | 4,232 d√©tails (100.0%) | ‚¨áÔ∏è 0 en cours | ‚ùå 2 erreurs
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        
        c.execute("SELECT COUNT(*) FROM torrents")
        total = c.fetchone()[0]
        
        c.execute("SELECT COUNT(*) FROM torrent_details")
        details = c.fetchone()[0]
        
        c.execute("SELECT COUNT(*) FROM torrent_details WHERE status = 'downloading'")
        downloading = c.fetchone()[0] or 0
        
        c.execute("SELECT COUNT(*) FROM torrent_details WHERE status = 'error'")
        errors = c.fetchone()[0] or 0
        
        coverage = (details / total * 100) if total > 0 else 0
        
        print(f"üìä {total:,} torrents | {details:,} d√©tails ({coverage:.1f}%) | "
              f"‚¨áÔ∏è {downloading} en cours | ‚ùå {errors} erreurs")

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                     SECTION 7: DIAGNOSTIC ET MAINTENANCE                  ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def analyze_error_type(error_msg, status):
    """
    Analyse automatique du type d'erreur bas√© sur le message d'erreur
    
    Types d'erreurs d√©tect√©s:
    - ‚è±Ô∏è Timeout r√©seau (temporaire)
    - üîç Torrent introuvable (supprim√© de RD)
    - üö´ Acc√®s refus√© (probl√®me d'autorisation)
    - üñ•Ô∏è Erreur serveur Real-Debrid
    - üìä Quota API d√©pass√©
    - üåê Probl√®me de connexion
    - üìã Donn√©es malform√©es
    
    Args:
        error_msg (str): Message d'erreur
        status (str): Statut du torrent
        
    Returns:
        str: Type d'erreur avec emoji et description
    """
    if not error_msg:
        return "‚ùì Erreur inconnue (pas de message)"
    
    error_lower = error_msg.lower()
    
    if "timeout" in error_lower or "time out" in error_lower:
        return "‚è±Ô∏è Timeout r√©seau (temporaire)"
    elif "404" in error_lower or "not found" in error_lower:
        return "üîç Torrent introuvable (supprim√© de RD)"
    elif "403" in error_lower or "forbidden" in error_lower:
        return "üö´ Acc√®s refus√© (probl√®me d'autorisation)"
    elif "500" in error_lower or "502" in error_lower or "503" in error_lower:
        return "üñ•Ô∏è Erreur serveur Real-Debrid (temporaire)"
    elif "quota" in error_lower or "limit" in error_lower:
        return "üìä Quota API d√©pass√© (temporaire)"
    elif "connection" in error_lower:
        return "üåê Probl√®me de connexion (temporaire)"
    elif "json" in error_lower or "parse" in error_lower:
        return "üìã Donn√©es malform√©es (temporaire)"
    else:
        return f"‚ùì Erreur sp√©cifique : {error_msg[:50]}..."

def get_error_suggestion(error_msg, status):
    """
    Propose une solution sp√©cifique bas√©e sur le type d'erreur d√©tect√©
    
    Args:
        error_msg (str): Message d'erreur
        status (str): Statut du torrent
        
    Returns:
        str: Suggestion d'action corrective avec emoji
    """
    if not error_msg:
        return "üîÑ Retry avec --sync-smart"
    
    error_lower = error_msg.lower()
    
    if "timeout" in error_lower or "connection" in error_lower:
        return "üîÑ Retry automatique recommand√© (erreur r√©seau temporaire)"
    elif "404" in error_lower or "not found" in error_lower:
        return "üóëÔ∏è Torrent probablement supprim√© - consid√©rer suppression de la base"
    elif "403" in error_lower:
        return "üîë V√©rifier la validit√© du token Real-Debrid"
    elif "500" in error_lower or "502" in error_lower:
        return "‚è≥ Attendre et retry plus tard (probl√®me serveur RD)"
    elif "quota" in error_lower:
        return "‚è∞ Attendre la r√©initialisation du quota (1 heure max)"
    else:
        return "üîÑ Retry avec --sync-smart ou --details-only --status error"

def diagnose_errors():
    """
    Diagnostique d√©taill√© des torrents en erreur avec analyse automatique
    
    Fonctionnalit√©s:
    - üìã Informations compl√®tes de chaque erreur
    - üî¨ Analyse automatique du type d'erreur
    - üí° Suggestions d'actions correctives
    - üìä R√©sum√© statistique par type d'erreur
    - üõ†Ô∏è Commandes exactes pour r√©soudre
    
    Usage: python src/main.py --diagnose-errors
    """
    with sqlite3.connect(DB_PATH) as conn:
        c = conn.cursor()
        
        # R√©cup√©rer tous les torrents en erreur avec leurs d√©tails
        c.execute("""
            SELECT td.id, td.name, td.status, td.error, td.progress, 
                   t.filename, t.added_on, t.bytes
            FROM torrent_details td
            LEFT JOIN torrents t ON td.id = t.id
            WHERE td.status = 'error' OR td.error IS NOT NULL
            ORDER BY t.added_on DESC
        """)
        
        errors = c.fetchall()
        
        if not errors:
            print("‚úÖ Aucun torrent en erreur trouv√© !")
            return
        
        print(f"\nüîç DIAGNOSTIC DES ERREURS ({len(errors)} torrents)")
        print("="*80)
        
        # Analyse d√©taill√©e de chaque erreur
        for i, (torrent_id, name, status, error, progress, filename, added_on, bytes_size) in enumerate(errors, 1):
            print(f"\n‚ùå ERREUR #{i}")
            print(f"   üÜî ID             : {torrent_id}")
            print(f"   üìÅ Nom            : {name or filename or 'N/A'}")
            print(f"   üìä Statut         : {status}")
            print(f"   ‚ö†Ô∏è  Message d'erreur: {error or 'Aucun message sp√©cifique'}")
            print(f"   üìà Progression    : {progress or 0}%")
            print(f"   üìÖ Ajout√© le      : {added_on}")
            print(f"   üíæ Taille         : {format_size(bytes_size) if bytes_size else 'N/A'}")
            
            # Analyse automatique du type d'erreur
            error_type = analyze_error_type(error, status)
            print(f"   üî¨ Type d'erreur  : {error_type}")
            
            # Suggestion de correction personnalis√©e
            suggestion = get_error_suggestion(error, status)
            print(f"   üí° Suggestion     : {suggestion}")
            print("-" * 80)
        
        # R√©sum√© statistique des types d'erreurs
        print(f"\nüìä R√âSUM√â DES TYPES D'ERREURS")
        error_types = {}
        for _, _, _, error, _, _, _, _ in errors:
            error_type = analyze_error_type(error, None)
            error_types[error_type] = error_types.get(error_type, 0) + 1
        
        for error_type, count in sorted(error_types.items(), key=lambda x: x[1], reverse=True):
            print(f"   ‚Ä¢ {error_type} : {count}")
        
        # Actions recommand√©es avec commandes exactes
        print(f"\nüí° ACTIONS RECOMMAND√âES :")
        print(f"   üîÑ Retry automatique    : python src/main.py --sync-smart")
        print(f"   üéØ Retry forc√©          : python src/main.py --details-only --status error")
        print(f"   üìä V√©rifier l'√©tat      : python src/main.py --stats")

def diagnose_token():
    """
    Diagnostique le token pour identifier les probl√®mes de configuration
    
    Analyse:
    - Variables d'environnement
    - Fichiers de configuration
    - Validation du format
    - Test Header Injection
    
    Usage: Fonction utilitaire pour debug
    """
    import re
    
    print("\nüîç DIAGNOSTIC DU TOKEN REAL-DEBRID")
    print("=" * 60)
    
    load_env_file()
    
    # Test variable d'environnement
    env_token = os.getenv('RD_TOKEN')
    if env_token:
        print(f"üìå TOKEN VARIABLE D'ENVIRONNEMENT")
        print(f"   Longueur: {len(env_token)} caract√®res")
        print(f"   Repr√©sentation: {repr(env_token)}")
        print(f"   Contient \\n: {'OUI' if '\\n' in env_token else 'NON'}")
        print(f"   Contient \\r: {'OUI' if '\\r' in env_token else 'NON'}")
        print(f"   Apr√®s strip(): {repr(env_token.strip())}")
        
        # Validation format
        is_valid = re.match(r'^[A-Za-z0-9_-]+$', env_token.strip())
        print(f"   Format valide: {'‚úÖ OUI' if is_valid else '‚ùå NON'}")
    else:
        print("üìå TOKEN VARIABLE D'ENVIRONNEMENT: Absent")
    
    # Test fichier config
    config_file = os.path.join(os.path.dirname(__file__), "../config/rd_token.conf")
    if os.path.exists(config_file):
        print(f"\nüìÅ TOKEN FICHIER CONFIG")
        
        # Lecture en mode binaire pour voir tous les caract√®res
        with open(config_file, 'rb') as f:
            file_content = f.read()
        
        print(f"   Taille fichier: {len(file_content)} bytes")
        print(f"   Contenu brut: {repr(file_content)}")
        
        try:
            text_content = file_content.decode('utf-8')
            print(f"   Contenu texte: {repr(text_content)}")
            print(f"   Apr√®s strip(): {repr(text_content.strip())}")
                
        except UnicodeDecodeError as e:
            print(f"   ‚ùå Erreur d'encodage: {e}")
    else:
        print(f"\nüìÅ TOKEN FICHIER CONFIG: {config_file} n'existe pas")
    
    # Test token final (simulation de load_token)
    print(f"\nüî¨ TEST LOAD_TOKEN()")
    
    try:
        token = load_token()
        print(f"   ‚úÖ Token charg√© avec succ√®s")
        print(f"   Longueur: {len(token)} caract√®res")
        print(f"   Repr√©sentation: {repr(token)}")
        
        # Test validation regex
        is_valid = re.match(r'^[A-Za-z0-9_-]+$', token)
        print(f"   Format valide: {'‚úÖ OUI' if is_valid else '‚ùå NON'}")
        
        # Test de l'erreur Header Injection
        print(f"\nüö® TEST HEADER INJECTION")
        test_header_value = f"Bearer {token}"
        
        dangerous_chars = ['\n', '\r', '\r\n']
        header_safe = True
        
        for dangerous_char in dangerous_chars:
            if dangerous_char in test_header_value:
                print(f"   ‚ùå Caract√®re dangereux d√©tect√©: {repr(dangerous_char)}")
                header_safe = False
        
        if header_safe:
            print(f"   ‚úÖ Header Authorization s√ªr")
        else:
            print(f"   ‚ùå Header Authorization DANGEREUX")
        
    except SystemExit:
        print("   ‚ùå √âchec du chargement du token")
    
    print(f"\n" + "=" * 60)

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                    SECTION 8: INTERFACE UTILISATEUR (MENU)                ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def show_interactive_menu():
    """
    Menu interactif principal pour faciliter l'utilisation de Redriva
    
    Fonctionnalit√©s:
    - üéØ Interface guid√©e avec choix num√©rot√©s
    - ‚ö° Acc√®s direct aux fonctions principales
    - üí° Guide int√©gr√© avec recommandations
    - üîÑ Navigation fluide avec retour automatique
    - üèÉ Mode hybride vers ligne de commande
    
    Categories du menu:
    - üìä Informations & Diagnostic  
    - üîÑ Synchronisation
    - üîß Maintenance
    - ‚ùì Aide & Sortie
    
    Returns:
        bool: True si le programme doit se terminer, False pour continuer en CLI
    """
    import os
    
    while True:
        # Effacer l'√©cran (compatible Linux/Mac/Windows)
        os.system('clear' if os.name == 'posix' else 'cls')
        
        print("‚ïî" + "‚ïê" * 58 + "‚ïó")
        print("‚ïë" + " " * 20 + "üöÄ MENU REDRIVA" + " " * 20 + "‚ïë")
        print("‚ï†" + "‚ïê" * 58 + "‚ï£")
        print("‚ïë Outil de synchronisation Real-Debrid                  ‚ïë")
        print("‚ïö" + "‚ïê" * 58 + "‚ïù")
        
        print("\nüìä INFORMATIONS & DIAGNOSTIC")
        print("  1. üìà Statistiques compl√®tes")
        print("  2. üìã Statistiques compactes")
        print("  3. üîç Diagnostiquer les erreurs")
        
        print("\nüîÑ SYNCHRONISATION")
        print("  4. üß† Sync intelligent (recommand√©)")
        print("  5. üöÄ Sync rapide complet")
        print("  6. üìã Torrents uniquement (ultra-rapide)")
        print("  7. üìñ Sync classique complet")
        print("  8. ‚èÆÔ∏è  Reprendre sync interrompu")
        
        print("\nüîß MAINTENANCE")
        print("  9. üîÑ D√©tails uniquement")
        print(" 10. ‚ùå Retry torrents en erreur")
        print(" 11. ‚¨áÔ∏è  Mise √† jour t√©l√©chargements actifs")
        print(" 12. üóëÔ∏è  Vider la base de donn√©es")
        print(" 13. üîç Diagnostic du token")
        
        print("\n‚ùì AIDE & SORTIE")
        print(" 14. üí° Guide de choix rapide")
        print(" 15. üèÉ Mode commande (passer aux arguments)")
        print("  0. üö™ Quitter")
        
        print("\n" + "‚îÄ" * 60)
        
        try:
            choice = input("üëâ Votre choix (0-15) : ").strip()
            
            if choice == "0":
                print("\nüëã Au revoir ! Merci d'utiliser Redriva.")
                break
                
            elif choice == "1":
                print("\nüîÑ Chargement des statistiques compl√®tes...")
                show_stats()
                input("\nüìä Appuyez sur Entr√©e pour continuer...")
                
            elif choice == "2":
                print("\nüìä Statistiques compactes :")
                show_stats_compact()
                input("\nüìã Appuyez sur Entr√©e pour continuer...")
                
            elif choice == "3":
                print("\nüîç Diagnostic des erreurs en cours...")
                diagnose_errors()
                input("\nüîß Appuyez sur Entr√©e pour continuer...")
                
            elif choice == "4":
                token = get_token()
                if token:
                    print("\nüß† Synchronisation intelligente en cours...")
                    sync_smart(token)
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "5":
                token = get_token()
                if token:
                    print("\nüöÄ Synchronisation rapide en cours...")
                    sync_all_v2(token)
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "6":
                token = get_token()
                if token:
                    print("\nüìã Synchronisation des torrents uniquement...")
                    sync_torrents_only(token)
                    input("\nüìã Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "7":
                token = get_token()
                if token:
                    confirm = input("\n‚ö†Ô∏è  Sync classique (peut prendre plusieurs heures). Continuer ? (o/N): ")
                    if confirm.lower() in ['o', 'oui', 'y', 'yes']:
                        sync_all(token)
                        input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                    else:
                        print("‚ùå Annul√©.")
                        input("üìã Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "8":
                token = get_token()
                if token:
                    print("\n‚èÆÔ∏è  Reprise de la synchronisation...")
                    sync_resume(token)
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "9":
                token = get_token()
                if token:
                    print("\nüîÑ Mise √† jour des d√©tails uniquement...")
                    sync_details_only(token)
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "10":
                token = get_token()
                if token:
                    print("\n‚ùå Retry des torrents en erreur...")
                    sync_details_only(token, status_filter="error")
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "11":
                token = get_token()
                if token:
                    print("\n‚¨áÔ∏è  Mise √† jour des t√©l√©chargements actifs...")
                    sync_details_only(token, status_filter="downloading")
                    input("\n‚úÖ Appuyez sur Entr√©e pour continuer...")
                else:
                    input("\n‚ùå Token manquant. Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "12":
                confirm = input("\n‚ö†Ô∏è  ATTENTION : Vider compl√®tement la base de donn√©es ? (tapez 'SUPPRIMER'): ")
                if confirm == "SUPPRIMER":
                    clear_database()
                    input("\nüóëÔ∏è  Base vid√©e. Appuyez sur Entr√©e pour continuer...")
                else:
                    print("‚ùå Annul√©.")
                    input("üìã Appuyez sur Entr√©e pour continuer...")
                    
            elif choice == "13":
                print("\nüîç Diagnostic du token en cours...")
                diagnose_token()
                input("\nüîß Appuyez sur Entr√©e pour continuer...")
                
            elif choice == "14":
                show_quick_guide()
                input("\nüí° Appuyez sur Entr√©e pour continuer...")
                
            elif choice == "15":
                print("\nüèÉ Passage en mode commande...")
                print("üí° Utilisez: python src/main.py --help pour voir toutes les options")
                print("üìã Exemple: python src/main.py --sync-smart")
                return False  # Retourne False pour continuer avec les arguments CLI
                
            else:
                input("\n‚ùå Choix invalide. Appuyez sur Entr√©e pour continuer...")
                
        except KeyboardInterrupt:
            print("\n\nüëã Interruption d√©tect√©e. Au revoir !")
            break
        except Exception as e:
            print(f"\n‚ùå Erreur : {e}")
            input("üîß Appuyez sur Entr√©e pour continuer...")
    
    return True  # Retourne True si le programme doit se terminer

def show_quick_guide():
    """
    Guide de choix rapide pour aider les utilisateurs √† choisir les bonnes options
    
    Recommandations par cas d'usage:
    - ü•á Premi√®re utilisation
    - üìÖ Usage quotidien  
    - üîß Maintenance
    - ‚ö° Vitesses approximatives
    - ‚ùì En cas de doute
    """
    print("\n" + "‚ïî" + "‚ïê" * 58 + "‚ïó")
    print("‚ïë" + " " * 18 + "üí° GUIDE DE CHOIX" + " " * 18 + "‚ïë")
    print("‚ïö" + "‚ïê" * 58 + "‚ïù")
    
    print("\nüéØ UTILISATION RECOMMAND√âE :")
    print("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ ü•á PREMI√àRE FOIS :                                     ‚îÇ")
    print("‚îÇ    ‚Üí Choix 5 : Sync rapide complet (7-10 min)         ‚îÇ")
    print("‚îÇ                                                         ‚îÇ")
    print("‚îÇ üìÖ USAGE QUOTIDIEN :                                   ‚îÇ")
    print("‚îÇ    ‚Üí Choix 2 : Stats compactes (<1s)                  ‚îÇ")
    print("‚îÇ    ‚Üí Choix 4 : Sync intelligent (30s-2min)            ‚îÇ")
    print("‚îÇ                                                         ‚îÇ")
    print("‚îÇ üîß MAINTENANCE :                                        ‚îÇ")
    print("‚îÇ    ‚Üí Choix 1 : Stats compl√®tes + recommandations      ‚îÇ")
    print("‚îÇ    ‚Üí Choix 3 : Diagnostic si probl√®mes                ‚îÇ")
    print("‚îÇ    ‚Üí Choix 10: Retry erreurs si n√©cessaire            ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    print("\n‚ö° VITESSES APPROXIMATIVES :")
    print("  üìä Stats (1-2)     : <1 seconde")
    print("  üß† Sync smart (4)  : 30s - 2 minutes")
    print("  üöÄ Sync rapide (5) : 7-10 minutes")
    print("  üìã Torrents (6)    : 10-30 secondes")
    print("  üìñ Sync classique  : 4-6 heures (non recommand√©)")
    
    print("\n‚ùì EN CAS DE DOUTE :")
    print("  üëâ Commencez par le choix 2 (stats compactes)")
    print("  üëâ Puis choix 4 (sync intelligent)")
    print("  üëâ Choix 1 pour analyse d√©taill√©e si besoin")

def get_token():
    """
    R√©cup√®re le token avec v√©rification et messages d'aide
    
    Returns:
        str/None: Token valide ou None si non trouv√©
    """
    load_env_file()  # Charger les variables d'environnement
    
    # Essayer de r√©cup√©rer le token
    token = os.getenv('RD_TOKEN')
    if not token:
        try:
            with open('config/rd_token.conf', 'r') as f:
                token = f.read().strip()
        except FileNotFoundError:
            pass
    
    if not token:
        print("\n‚ùå ERREUR : Token Real-Debrid non trouv√© !")
        print("üîß Veuillez configurer votre token :")
        print("   ‚Ä¢ Variable d'environnement : export RD_TOKEN='votre_token'")
        print("   ‚Ä¢ Fichier config : cp config/rd_token.conf.example config/rd_token.conf")
        print("   ‚Ä¢ Fichier .env : cp .env.example .env")
    
    return token

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë                        SECTION 9: POINT D'ENTR√âE PRINCIPAL                ‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

def main():
    """
    Point d'entr√©e principal avec support menu interactif et arguments CLI
    
    Logique:
    - Si aucun argument : lance le menu interactif
    - Sinon : traite les arguments de ligne de commande
    
    Arguments support√©s:
    - Synchronisation : --sync-all, --sync-fast, --sync-smart, --resume, etc.
    - Statistiques : --stats, --stats --compact  
    - Diagnostic : --diagnose-errors
    - Maintenance : --details-only, --clear, --torrents-only
    """
    load_env_file()  # Charger les variables d'environnement au d√©but
    
    parser = argparse.ArgumentParser(description="Redriva - Synchroniseur Real-Debrid vers SQLite")
    
    # Si aucun argument n'est fourni, lancer le menu interactif
    if len(sys.argv) == 1:
        try:
            should_exit = show_interactive_menu()
            if should_exit:
                return
        except KeyboardInterrupt:
            print("\nüëã Au revoir !")
            return
    
    # === ARGUMENTS DE LIGNE DE COMMANDE ===
    
    # Arguments classiques
    parser.add_argument('--sync-all', action='store_true', 
                       help="üîÑ Synchronisation compl√®te classique (4-6h)")
    parser.add_argument('--details-only', action='store_true', 
                       help="üìù Synchroniser uniquement les d√©tails des torrents existants")
    parser.add_argument('--status', 
                       help="üîç Filtrer par status (downloaded, error, downloading, etc.)")
    parser.add_argument('--stats', action='store_true', 
                       help="üìä Afficher les statistiques de la base")
    parser.add_argument('--compact', action='store_true', 
                       help="üìã Affichage compact des statistiques")
    parser.add_argument('--clear', action='store_true', 
                       help="üóëÔ∏è Vider compl√®tement la base de donn√©es")
    
    # Arguments optimis√©s (nouvelles fonctionnalit√©s)
    parser.add_argument('--sync-fast', action='store_true', 
                       help="üöÄ Synchronisation rapide optimis√©e (7-10min)")
    parser.add_argument('--sync-smart', action='store_true', 
                       help="üß† Synchronisation intelligente - changements uniquement (30s-2min)")
    parser.add_argument('--resume', action='store_true', 
                       help="‚èÆÔ∏è  Reprendre une synchronisation interrompue")
    parser.add_argument('--torrents-only', action='store_true', 
                       help="üìã Synchroniser uniquement les torrents de base sans d√©tails (10-30s)")
    parser.add_argument('--diagnose-errors', action='store_true', 
                       help="üîç Diagnostic d√©taill√© des torrents en erreur avec suggestions")
    parser.add_argument('--diagnose-token', action='store_true', 
                       help="üîç Diagnostic complet du token Real-Debrid (debug)")
    parser.add_argument('--menu', action='store_true', 
                       help="üéÆ Afficher le menu interactif")
    
    args = parser.parse_args()

    # Initialisation
    token = load_token()
    create_tables()

    try:
        # === TRAITEMENT DES ARGUMENTS ===
        
        if args.menu:
            show_interactive_menu()
            
        elif args.clear:
            # Demander confirmation avant de vider
            response = input("‚ö†Ô∏è  √ätes-vous s√ªr de vouloir vider la base de donn√©es ? (oui/non): ")
            if response.lower() in ['oui', 'o', 'yes', 'y']:
                clear_database()
            else:
                print("‚ùå Op√©ration annul√©e.")
                
        elif args.stats:
            if args.compact:
                show_stats_compact()
            else:
                show_stats()
                
        elif args.diagnose_errors:
            diagnose_errors()
            
        elif args.diagnose_token:
            diagnose_token()
            
        elif args.torrents_only:
            sync_torrents_only(token)
            
        elif args.sync_fast:
            sync_all_v2(token)
            
        elif args.sync_smart:
            sync_smart(token)
            
        elif args.resume:
            sync_resume(token)
            
        elif args.details_only:
            sync_details_only(token, args.status)
            
        elif args.sync_all:
            sync_all(token)
            
        else:
            # Aucun argument reconnu, afficher l'aide
            parser.print_help()
            print(f"\nüí° Astuce : Lancez simplement 'python src/main.py' pour le menu interactif !")
            
    except KeyboardInterrupt:
        logging.warning("Arr√™t manuel par l'utilisateur.")
    except Exception as e:
        logging.error(f"Erreur inattendue : {e}")

if __name__ == "__main__":
    main()
